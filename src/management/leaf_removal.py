"""
Leaf removal management module
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from src.utils.function import gompertz_growth
from src.configs.params import LEAF_REMOVAL


def process_leaf_removal(
    current_datetime, leaf_removal_dates, active_leaves, mode="file", params=None
):
    """
    Process leaf removal based on the specified mode

    Args:
        current_datetime (datetime): Current simulation time
        leaf_removal_dates (DataFrame): Dates when leaves are removed (relevant for 'file' mode)
        active_leaves (list): List of active leaf dictionaries. Each dict must have at least 'Leaf Number' and 'Date'.
        mode (str): Leaf removal mode ('file', 'interval', or 'threshold')
        params (dict): Parameters for leaf removal, must contain:
            - config (dict): The LEAF_REMOVAL dictionary from params.py
            - first_removal_done (bool): Flag for interval mode
            - end_date (datetime.date): End date for simulation
            - conversion_factor (float): Factor for leaf area conversion
            - result_df (DataFrame): DataFrame containing cumulative_thermal_time
            - gompertz_params (dict): Parameters for gompertz_growth function (a, b, c)
            - SLA (float): Specific Leaf Area for DW calculation

    Returns:
        tuple: (removed_leaf_details, updated_active_leaves, result_flag)
            - removed_leaf_details (list): List of dictionaries, each containing info about removed leaves for the current step.
            - updated_active_leaves (list): The list of active leaves after removal.
            - result_flag: Data generated by interval mode start (e.g., DataFrame of removal dates), None otherwise.
    """

    leaves_to_remove_list = []  # List of leaf dicts to be removed
    removed_leaf_details_list = []  # List to store details for the output sheet
    result_flag = None
    updated_active_leaves = list(active_leaves)  # Start with a copy

    # --- Get parameters from the passed params dict --- #
    params = params or {}
    config = params.get("config", {})  # Get the LEAF_REMOVAL config
    remove_oldest = config.get("remove_oldest_first", True)
    target_remaining = config.get("target_remaining_leaves", 15)
    conversion_factor = params.get("conversion_factor", 1)
    result_df = params.get("result_df")
    gompertz_params = params.get("gompertz_params", {"a": 1, "b": 1, "c": 1})
    first_removal_done = params.get("first_removal_done", False)
    end_date_sim = params.get("end_date")
    SLA = params.get("SLA")
    if SLA is None or SLA <= 0:
        print(
            "Warning: SLA is not provided or invalid in process_leaf_removal params. Cannot calculate removed DW."
        )
        SLA = None

    # Determine the removal time based on mode
    removal_time_str = "08:00:00"  # Default
    if mode == "interval":
        removal_time_str = config.get("interval", {}).get("time", "08:00:00")
    elif mode == "threshold":
        # Threshold mode might use interval's time or a root level default (if defined)
        # For now, let's assume it also uses interval's time or the default
        removal_time_str = config.get("interval", {}).get("time", "08:00:00")
    # 'file' mode checks time directly from the file data later

    try:
        removal_time_obj = pd.to_datetime(removal_time_str).time()
    except ValueError:
        print(
            f"Warning: Invalid leaf_removal_time format '{removal_time_str}' in config. Using 08:00:00."
        )
        removal_time_obj = pd.to_datetime("08:00:00").time()

    current_date = current_datetime.date()
    current_time = current_datetime.time()

    # --- Logic to determine if removal should happen at this time step --- #
    should_check_removal = False
    if mode == "file":
        if not leaf_removal_dates.empty:
            try:
                # Ensure Time column is in time format for comparison
                if "Time" in leaf_removal_dates.columns and pd.api.types.is_datetime64_any_dtype(
                    leaf_removal_dates["Time"]
                ):
                    check_time_col = leaf_removal_dates["Time"].dt.time
                elif "Time" in leaf_removal_dates.columns:
                    # Attempt conversion if not datetime/time already
                    check_time_col = pd.to_datetime(
                        leaf_removal_dates["Time"], format="%H:%M:%S", errors="coerce"
                    ).dt.time
                else:
                    check_time_col = pd.Series(
                        [removal_time_obj] * len(leaf_removal_dates)
                    )  # Fallback

                matching_dates = leaf_removal_dates[
                    (leaf_removal_dates["Date"] == current_date) & (check_time_col == current_time)
                ]
                if not matching_dates.empty:
                    should_check_removal = True
            except Exception as e:
                print(f"Error checking file removal dates: {e}")
                # Decide how to handle error, maybe skip this check

    elif mode == "interval":
        interval_config = config.get("interval", {})

        if current_time == removal_time_obj:
            first_leaf_count = interval_config.get("first_leaf_count")
            if (
                not first_removal_done
                and first_leaf_count is not None
                and len(active_leaves) >= first_leaf_count
            ):
                should_check_removal = True

            elif first_removal_done:
                # Check subsequent removals based on generated dates (passed in leaf_removal_dates)
                if not leaf_removal_dates.empty:
                    try:
                        # Ensure Date column is date objects
                        check_date_col = pd.to_datetime(leaf_removal_dates["Date"]).dt.date
                        # Robustly convert Time column to time objects for comparison
                        if "Time" in leaf_removal_dates.columns:
                            check_time_col = pd.to_datetime(
                                leaf_removal_dates["Time"], errors="coerce"
                            ).dt.time
                        else:  # Fallback if Time column is missing (should not happen ideally)
                            check_time_col = pd.Series([removal_time_obj] * len(leaf_removal_dates))

                        matching_dates = leaf_removal_dates[
                            (check_date_col == current_date) & (check_time_col == current_time)
                        ]
                        if not matching_dates.empty:
                            should_check_removal = True

                    except Exception as e:
                        print(f"Error checking interval removal dates: {e}")

    elif mode == "threshold":
        if current_time == removal_time_obj:
            threshold_config = config.get("threshold", {})
            max_leaves = threshold_config.get("max_leaves", 20)
            if len(active_leaves) >= max_leaves:
                should_check_removal = True

    # --- Perform removal if conditions met --- #
    if should_check_removal:

        leaves_to_remove_count = 0
        if len(active_leaves) > target_remaining:
            leaves_to_remove_count = len(active_leaves) - target_remaining
        else:
            # If not exceeding target remaining, check mode-specific removal count
            if mode == "file" and "target_leaves" in config:
                leaves_to_remove_count = min(config["target_leaves"], len(active_leaves))
            elif mode == "threshold":
                threshold_cfg = config.get("threshold", {})
                if "leaves_to_remove" in threshold_cfg:
                    leaves_to_remove_count = min(
                        threshold_cfg["leaves_to_remove"], len(active_leaves)
                    )
            # Interval mode primarily uses target_remaining, might not have a separate count

        if leaves_to_remove_count > 0:
            # Sort active leaves by appearance date (oldest first)
            try:
                sorted_leaves = sorted(active_leaves, key=lambda x: pd.Timestamp(x["Date"]))
            except TypeError as e:
                print(f"Error sorting leaves: {e}. Check leaf date format.")
                print(f"Problematic leaf data: {active_leaves[:5]}...")
                return removed_leaf_details_list, updated_active_leaves, result_flag

            if remove_oldest:
                leaves_to_remove_list = sorted_leaves[:leaves_to_remove_count]
            else:
                leaves_to_remove_list = sorted_leaves[-leaves_to_remove_count:]

            # --- Calculate removed area and create details --- #
            if leaves_to_remove_list:
                removed_leaf_numbers = [leaf["Leaf Number"] for leaf in leaves_to_remove_list]
                cumulative_tt_now = np.nan
                if result_df is not None and current_datetime in result_df.index:
                    cumulative_tt_now = result_df.loc[current_datetime, "cumulative_thermal_time"]
                else:
                    print(
                        f"Warning: Could not find cumulative_thermal_time for {current_datetime} to calculate removed leaf area."
                    )

                removed_leaf_area_sum_cm2 = 0
                removed_leaf_dw_sum_g = 0

                if not np.isnan(cumulative_tt_now):
                    try:
                        individual_leaf_details = []
                        for leaf in leaves_to_remove_list:
                            leaf_tt_age = (
                                cumulative_tt_now - leaf["Thermal Time"]
                                if "Thermal Time" in leaf
                                else np.nan
                            )
                            if np.isnan(leaf_tt_age) or leaf_tt_age < 0:
                                leaf_area_cm2 = 0
                            else:
                                leaf_area_cm2 = gompertz_growth(
                                    leaf_tt_age,
                                    gompertz_params["a"],
                                    gompertz_params["b"],
                                    gompertz_params["c"],
                                )

                            leaf_area_m2 = leaf_area_cm2 * conversion_factor
                            leaf_dw_g = 0
                            if SLA is not None:
                                leaf_dw_g = leaf_area_m2 / SLA

                            individual_leaf_details.append(
                                {
                                    "area_cm2": leaf_area_cm2,
                                    "area_m2": leaf_area_m2,
                                    "dw_g": leaf_dw_g,
                                }
                            )
                            removed_leaf_area_sum_cm2 += leaf_area_cm2
                            removed_leaf_dw_sum_g += leaf_dw_g

                    except KeyError as e:
                        print(
                            f"Error calculating removed area/DW: Missing key {e} in gompertz_params or leaf dict."
                        )
                        print(f"Gompertz Params: {gompertz_params}")
                        print(
                            f"Sample leaf: {leaves_to_remove_list[0] if leaves_to_remove_list else 'N/A'}"
                        )
                        removed_leaf_area_sum_cm2 = 0
                        removed_leaf_dw_sum_g = 0
                else:
                    removed_leaf_area_sum_cm2 = 0
                    removed_leaf_dw_sum_g = 0

                removed_leaf_area_m2 = removed_leaf_area_sum_cm2 * conversion_factor

                removed_leaf_details_list.append(
                    {
                        "Date": current_date,
                        "Time": current_time,
                        "Removed Leaves": removed_leaf_numbers,
                        "Removed Leaf Count": len(removed_leaf_numbers),
                        "Removed Leaf Area (cm2)": removed_leaf_area_sum_cm2,
                        "Removed Leaf Area (m2)": removed_leaf_area_m2,
                        "Removed Leaf DW (g)": removed_leaf_dw_sum_g,
                        "Remaining Leaves Before": len(active_leaves),
                        "Remaining Leaves After": len(active_leaves) - len(removed_leaf_numbers),
                        "Removal Date": current_datetime,
                    }
                )

                # --- Update the active leaves list --- #
                leaf_numbers_to_remove_set = set(removed_leaf_numbers)
                updated_active_leaves = [
                    leaf
                    for leaf in active_leaves
                    if leaf["Leaf Number"] not in leaf_numbers_to_remove_set
                ]

    # Return the details, updated list, and flag
    return removed_leaf_details_list, updated_active_leaves, result_flag


def generate_leaf_removal_dates(
    start_date, end_date, interval_days=7, removal_time="08:00:00", first_date=None
):
    """
    Generate leaf removal dates at regular intervals

    Args:
        start_date (str or datetime): Start date for simulation
        end_date (str or datetime): End date for simulation
        interval_days (int): Days between leaf removals
        removal_time (str): Time of day for leaf removal (HH:MM:SS)
        first_date (str or datetime): First date for removal (if None, uses start_date)

    Returns:
        DataFrame: DataFrame with Date and Time columns
    """
    # Convert string dates to datetime objects if needed
    if isinstance(start_date, str):
        start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
    if isinstance(end_date, str):
        end_date = datetime.strptime(end_date, "%Y-%m-%d").date()

    # Handle None or empty string for first_date
    if first_date is None or (isinstance(first_date, str) and not first_date.strip()):
        # If first_date is not specified, use start_date + interval_days
        first_date = start_date + timedelta(days=interval_days)
    elif isinstance(first_date, str):
        first_date = datetime.strptime(first_date, "%Y-%m-%d").date()

    # Ensure first_date is after start_date and before end_date
    if first_date < start_date:
        first_date = start_date
    if first_date > end_date:
        # No removal dates possible
        return pd.DataFrame(columns=["Date", "Time"])

    # Generate dates at regular intervals
    dates = []
    current_date = first_date
    removal_time_obj = pd.to_datetime(
        removal_time
    ).time()  # Convert removal_time string to time object

    while current_date <= end_date:
        dates.append({"Date": current_date, "Time": removal_time_obj})  # Use time object
        current_date += timedelta(days=interval_days)

    return pd.DataFrame(dates)
